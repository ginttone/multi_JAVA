# JDBC_1105

문제 1. emp테이블에서, sal가 가장 많은 사원 3명을 출력하기(내림차순)

```sql WORKBENCH
SELECT * FROM emp ORDER BY sal DESC;
```

| EMPNO | ENAME  | JOB       | MGR  | HIRDATE             | SAL  | COMM | DEPINO |
| ----- | ------ | --------- | ---- | ------------------- | ---- | ---- | ------ |
| 7839  | KING   | PRESIDENT |      | 1981-11-17 00:00:00 | 5000 |      | 10     |
| 7788  | SCOTT  | ANALYST   | 7566 | 1987-04-19 00:00:00 | 3000 |      | 20     |
| 7902  | FORD   | ANALYST   | 7566 | 1981-12-03 00:00:00 | 3000 |      | 20     |
| 7566  | JONES  | MANAGER   | 7839 | 1981-04-02 00:00:00 | 2975 |      | 20     |
| 7698  | BLAKE  | MANAGER   | 7839 | 1981-05-01 00:00:00 | 2850 |      | 30     |
| 7782  | CLARK  | MANAGER   | 7839 | 1981-06-09 00:00:00 | 2450 |      | 10     |
| 7499  | ALLEN  | SALESMAN  | 7698 | 1981-02-20 00:00:00 | 1600 | 300  | 30     |
| 7844  | TURNER | SALESMAN  | 7698 | 1981-09-08 00:00:00 | 1500 | 0    | 30     |
| 7934  | MILLER | CLERK     | 7782 | 1982-01-23 00:00:00 | 1300 |      | 10     |
| 7521  | WARD   | SALESMAN  | 7698 | 1981-02-22 00:00:00 | 1250 | 500  | 30     |
| 7654  | MARTIN | SALESMAN  | 7698 | 1981-09-28 00:00:00 | 1250 | 1400 | 30     |
| 7876  | ADAMS  | CLERK     | 7788 | 1987-05-23 00:00:00 | 1100 |      | 20     |
| 7900  | JAMES  | CLERK     | 7698 | 1981-12-03 00:00:00 | 950  |      | 30     |
| 7369  | SMITH  | CLERK     | 7902 | 1980-12-17 00:00:00 | 800  |      | 20     |



## Limit

출력 갯수를 제한하는 기능
시작은 0부터 ...0, 5...상위 5개만 출력

MySQL 에서만 사용가능

```sql
SELECT * FROM emp ORDER BY sal DESC limit 3;
```

| EMPNO | ENAME | JOB       | MGR  | HIRDATE             | SAL  | COMM | DEPINO |
| ----- | ----- | --------- | ---- | ------------------- | ---- | ---- | ------ |
| 7839  | KING  | PRESIDENT |      | 1981-11-17 00:00:00 | 5000 |      | 10     |
| 7902  | FORD  | ANALYST   | 7566 | 1981-12-03 00:00:00 | 3000 |      | 20     |
| 7788  | SCOTT | ANALYST   | 7566 | 1987-04-19 00:00:00 | 3000 |      | 20     |



## SQL에서 NULL값은 제대로 다룰 수 있어야 한다. 

1. comm 값은 아직 정해지지 않았거나(미확정) / 자격이 없거나(자격없음) 일 떄 사용되는 값이다.

2. 0 을 의미하는 값이 아니다.

3. 값이 없는 것도 아니다. 나름 의미를 가지는 값이다...1)에서 언급

4. 0과는 전혀다른 값이기 때문에 비교, 연산 적용이 안된다.
   ==> =, !=, +, -, x, / 연산자 사용 불가능.
   ==> 대신에 ifnull() 을 사용해서 값을 치환시키고 연산적용 가능하다.

   

 문제2. emp테이블에서 COMM을 받지 않은 사원을 검색..이름, 업무,COMM이 출력하기

```sql
SELECT ename,job,comm FROM emp WHERE comm =null;  -- 비교연산자 = 사용안됨
SELECT ename,job,comm FROM emp WHERE comm is null; -- comm이 null인 사원
SELECT ename,job,comm FROM emp WHERE comm is not null; -- comm이 null이 아닌 사원
```

```
mysql> SELECT ename,job,comm FROM emp WHERE comm is not null;
+--------+----------+------+
| ename  | job      | comm |
+--------+----------+------+
| ALLEN  | SALESMAN |  300 |
| WARD   | SALESMAN |  500 |
| MARTIN | SALESMAN | 1400 |
| TURNER | SALESMAN |    0 |
+--------+----------+------+
4 rows in set (0.00 sec)
```



연산을 적용할때는 IFNULL사용

```sql
SELECT sal, sal*12 + ifnull(comm,0) FROM emp;
```

```
mysql> SELECT sal, sal*12 + ifnull(comm,0) FROM emp;
+------+-------------------------+
| sal  | sal*12 + ifnull(comm,0) |
+------+-------------------------+
|  800 |                    9600 |
| 1600 |                   19500 |
| 1250 |                   15500 |
| 2975 |                   35700 |
| 1250 |                   16400 |
| 2850 |                   34200 |
| 2450 |                   29400 |
| 3000 |                   36000 |
| 5000 |                   60000 |
| 1500 |                   18000 |
| 1100 |                   13200 |
|  950 |                   11400 |
| 3000 |                   36000 |
| 1300 |                   15600 |
+------+-------------------------+
14 rows in set (0.00 sec)
```



ALIAS지정

```sql
SELECT sal, sal*12 + ifnull(comm,0) AnnualSalary FROM emp;
```

```
mysql> SELECT sal, sal*12 + ifnull(comm,0) AnnualSalary FROM emp;
+------+--------------+
| sal  | AnnualSalary |
+------+--------------+
|  800 |         9600 |
| 1600 |        19500 |
| 1250 |        15500 |
| 2975 |        35700 |
| 1250 |        16400 |
| 2850 |        34200 |
| 2450 |        29400 |
| 3000 |        36000 |
| 5000 |        60000 |
| 1500 |        18000 |
| 1100 |        13200 |
|  950 |        11400 |
| 3000 |        36000 |
| 1300 |        15600 |
+------+--------------+
14 rows in set (0.00 sec)
```



## 함수

### 1. 숫자함수

abs()  정수값출력  //음수값 나오면 안되서 이럴 때 씀

round()  반올림 

floor()  소숫점버림 

mod()  특정한수를어떤수로나눴을때나머지구함



문제3. 업무가 사장 인 사람과 업무가 SALESMAN인 사람의 급여지급차 를 출력하기...

ABS

```sql
SELECT * FROM emp ;
SELECT sal FROM emp WHERE job = 'PRESIDENT'; -- 사장급여 단일 값 5000 <-스칼라값 :one row,one column
SELECT sal FROM emp WHERE job = 'SALESMAN'; -- 1600, 1250, 1250, 1500

SELECT ABS((SELECT sal FROM emp WHERE job = 'PRESIDENT')-(SELECT sal FROM emp WHERE job = 'SALESMAN')) FROM emp; 

SELECT DISTINCT ABS((SELECT sal FROM emp WHERE ename = 'KING')-(SELECT sal FROM emp WHERE ename = 'ALLEN')) 급여차이 FROM emp; -- main쿼리 안에 서브 쿼리가 먼저 돌아간다. 서브쿼리 실행해서 스칼라 서브 쿼리가 나온다 이것으로 연산함.

```

서브 쿼리는 먼저 돌아가서 값을 리턴한다. 

```
mysql> SELECT DISTINCT ABS((SELECT sal FROM emp WHERE ename = 'KING')-(SELECT sal FROM emp WHERE ename = 'ALLEN')) 급여 차이 FROM emp;
+----------+
| 급여차이 |
+----------+
|     3400 |
+----------+
1 row in set (0.00 sec)
```





문제4.  사원 번호중에서 홀수번호만 출력하기...

MOD

```sql
SELECT ename, empno, job FROM emp WHERE mod(empno,2) = 1; 
```

```
mysql> SELECT ename, empno, job FROM emp WHERE mod(empno,2) = 1;
+-------+-------+-----------+
| ename | empno | job       |
+-------+-------+-----------+
| SMITH |  7369 | CLERK     |
| ALLEN |  7499 | SALESMAN  |
| WARD  |  7521 | SALESMAN  |
| KING  |  7839 | PRESIDENT |
+-------+-------+-----------+
4 rows in set (0.00 sec)
```



ROUND

```sql
SELECT ROUND(45.923); -- 소숫점 첫번째 자리에서 반올림이 진행 되기 때문에 정수가 됨
SELECT ROUND(45.923, 0); -- 위와 같은 의미
SELECT ROUND(45.923, 2); -- 2의 의미는 소수점 2번째 자리까지 출력을 의미(소수점 3번째에서 반올림)
```

```
mysql> SELECT ROUND(45.923, 2);
+------------------+
| ROUND(45.923, 2) |
+------------------+
|            45.92 |
+------------------+
1 row in set (0.00 sec)
```





### 2. 문자함수 

substring() 추출

concat() 붙힐때  

trim() 양쪽공백제거



### 3. 날짜함수

curdate() 연월일만출력

 year()  연도만 출력

month()  월에 해당부분만 출력

now()   today가 heading display 

sysdate()  today랑 같음 

```sql
SELECT now() today; -- today가 heading display 
SELECT sysdate() today; -- today랑 같음
SELECT curdate() today; -- 연월일 만  display

SELECT ename, year(hiredate) 입사년도 FROM emp;
SELECT ename, month(hiredate) 입사월 FROM emp;
```



Oracle 에서는 YEAT,MONTH 뽑을 땐 substr() 사용

substr(          ,시작위치, 글자길이) :: 부분적인 데이터 추출할때 사용, 0부터 카운팅

```sql
SELECT ename, substr(hiredate, 6, 2) 입사월 FROM emp; -- month() 추출
```



## Like 연산자

like연산자는 와일드카드 문법과 함께 이해하기!

- like 연산자 ::

ex) 훈련생들 중 '김'씨로 시작하는 학생들의 명단을 검색하겠다

​	  제품중에서 '삼성' 2글자 포함되는 모든 제품을 검색하겠다.

- 와일드카드 :: 

​		% (0 ~ many을 지칭) , _ (1:1 맵핑 됨)



사원 이름중에서 s로 시작하는 사원의 이름을 검색하기.

```sql
SELECT ename FROM emp WHERE ename LIKE 'S%'; 
```

```
mysql>  SELECT ename FROM emp WHERE ename LIKE 'S%'; 
+-------+
| ename |
+-------+
| SMITH |
| SCOTT |
+-------+
2 rows in set (0.00 sec)
```



문제6. 사원의 이름중에서 두번째 철자가 A인 사원을 검색.. LIKE  _A

```sql
 SELECT ename FROM emp WHERE ename LIKE '_A%';
```

```
mysql>  SELECT ename FROM emp WHERE ename LIKE '_A%';
+--------+
| ename  |
+--------+
| WARD   |
| MARTIN |
| JAMES  |
+--------+
3 rows in set (0.00 sec)
```



사원의 이름중에서 R철자가 포함된 모든 사원을 검색

```sql
SELECT ename FROM emp WHERE ename LIKE '%R%';
```

```
mysql> SELECT ename FROM emp WHERE ename LIKE '%R%';
+--------+
| ename  |
+--------+
| WARD   |
| MARTIN |
| CLARK  |
| TURNER |
| FORD   |
| MILLER |
+--------+
6 rows in set (0.00 sec)
```



# 1104 복습

DML + WEB


![jdbc03_flow](https://user-images.githubusercontent.com/83646543/140839753-7a47cd43-b3a7-4b28-9d42-78175a3e9e45.png)


![1105_1](https://user-images.githubusercontent.com/83646543/140839732-46152fa4-964a-462d-9a70-a7958470f748.png)


#### CustomerDAOImpl

jdbc03_Custom_MVC > jdbc.dao > CustomerDAOImpl.java

```java
package jdbc.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;

import config.ServerInfo;
import jdbc.vo.Customer;

public class CustomerDAOImpl implements CustomerDAO{
	//싱글통 생성
   private static CustomerDAOImpl dao = new CustomerDAOImpl();
   private CustomerDAOImpl() {
      System.out.println("DAOImple...Creating...");
   }
   public static CustomerDAOImpl getInstance() {
      return dao;
   }
   
   @Override
   public Connection getConnect() throws SQLException {
      // CONNECTION
		Connection conn = DriverManager.getConnection(ServerInfo.URL, ServerInfo.USER, ServerInfo.PASS);
		System.out.println("DB Server Connect..ok");
      return conn;
   }

   @Override
   public void closeAll(PreparedStatement ps, Connection conn) throws SQLException {
      // CLOSE
	   if(ps!=null) ps.close(); //생성이 됬으면 닫아라.
	   if(conn!=null) conn.close();
      
   }   

   @Override
   public void closeAll(ResultSet rs, PreparedStatement ps, Connection conn) throws SQLException {
      // CLOSE SELECT
	   if(rs !=null) rs.close();
	   closeAll(ps,conn);
   }
   
   
   ///////////------Business Logic-------///////////

   @Override
   public void registerCustomer(Customer vo) throws SQLException {
      // INSERT
      Connection conn = null;
      PreparedStatement ps = null;
      try {    	 
    	  conn = getConnect(); //로컬에 담음, 디비서버 연결
    	  
    	  String query = "INSERT INTO custom(num,name,addr) VALUES (?,?,?)";
    	  ps= conn.prepareStatement(query);
    	  
    	  // 바인딩 
    	  //  -----------------  VO  ----------------------------
    	  //  생성자, setter (Data Pack) :: 할당, 주입, 세팅, setter 
    	  //  getter(Data Unpack) :: 반환, 받아오다, getter
    	  //  ---------------------------------------------------
    	  ps.setInt(1, vo.getNum());
    	  ps.setString(2, vo.getName());
    	  ps.setString(3, vo.getAddr());
    	  
    	  // 호출 .. 이시점에 db서버의 테이블로 값이 들어간다.  
    	  ps.executeUpdate();
    	  System.out.println(vo.getName() + "가입이 되었습니다");
    	  
      }finally {
    	  closeAll(ps, conn);
      }
   }

   @Override
   public void deleteCustomer(int num) throws SQLException {
      // DELETE
      Connection conn = null;
      PreparedStatement ps = null;
      try {
    	  conn = getConnect();
    	  
    	  String query = "DELETE FROM custom WHERE num = ? ";
    	  ps = conn.prepareStatement(query);
    	  ps.setInt(1, num);  
			
    	 
    	  System.out.println( ps.executeUpdate()+ "분 탈퇴 되었습니다. "); // 결과로 1성공 0실패 값 나옴
      }finally {
    	  closeAll(ps, conn);
	  }	  
      
   }

   @Override
   public void updateCustomer(Customer vo) throws SQLException {
      // UPDATE
      Connection conn = null;
      PreparedStatement ps = null;
      try {
		  conn = getConnect();
		  
		  String query = "UPDATE custom SET name=?, addr=? WHERE num=?";
		  ps = conn.prepareStatement(query);		  
		 
		  //바인딩
		  ps.setString(1, vo.getName());
		  ps.setString(2, vo.getAddr());
		  ps.setInt(3, vo.getNum()); //PK 중요
					  
		  System.out.println(ps.executeUpdate()+ "분의 회원 정보가 수정되었습니다.");		
    	  
      }finally {
    	  closeAll(ps, conn);
      }
   }

   @Override
   public Customer getCustomer(int num) throws SQLException {
      // SELECT
      Connection conn = null;
      PreparedStatement ps = null;
      ResultSet rs = null;
      Customer cust = null; //리턴타입 있을때는 선언하고 들어가길 권장한다. if안에서 갇힐 수 있기 때문에 먼저 선언함
      try {
    	  
    	  conn = getConnect();
    	  String query = "SELECT * FROM custom WHERE num = ?";
    	  ps = conn.prepareStatement(query);
    	  
    	  ps.setInt(1, num);
    	  
    	  rs = ps.executeQuery();
    	  
    	  if(rs.next()) {
    		  
    		  cust= new Customer(num, rs.getString("name"), rs.getString("addr"));		
    	  }

    	  
      }finally {
    	  closeAll(rs, ps, conn);
      }
      return cust;
   }

   @Override
   public ArrayList<Customer> getAllCustomer() throws SQLException {
   		Connection conn = null;
   		PreparedStatement ps = null;
   		ResultSet rs = null;
   		ArrayList<Customer> list = new ArrayList<>(); //리턴타입이 컬랙션 컨테이너 일때는 생성해야해
   		try {
   			conn = getConnect();
   			String query = "SELECT * FROM custom ";
   			ps = conn.prepareStatement(query);
   			rs = ps.executeQuery();
   			
   			while(rs.next()) {
   				list.add(new Customer(rs.getInt("num"), rs.getString("name"), rs.getString("addr")));
   			}
   			
   		}finally {
   			closeAll(rs, ps, conn);
   		}
   		return list;
   }

}
```



#### CustomerClientTest

jdbc03_Custom_MVC > jdbc.client > CustomerClientTest.java

```java
package jdbc.client;

import java.util.ArrayList;

import config.ServerInfo;
import jdbc.dao.CustomerDAOImpl;
import jdbc.vo.Customer;

public class CustomerClientTest{
	static {
		try {
			Class.forName(ServerInfo.DRIVER_NAME);
			System.out.println("Driver Loading Success...");
		}catch(ClassNotFoundException e) {
			System.out.println("Driver Loading Fail...");
		}
	}

	public static void main(String[] args) throws Exception{
		//싱글톤으로 하나 만들어 놓은 객체를 받아서 사용
		CustomerDAOImpl dao = CustomerDAOImpl.getInstance();

//		dao.registerCustomer(new Customer(444,"아이유","방배동"));
//						
//		dao.updateCustomer(new Customer(333, "tom","방학동"));
//		
//		dao.deleteCustomer(444);
		
//		dao.getCustomer(222);
		
		ArrayList<Customer> list = dao.getAllCustomer();
		for(Customer c: list) {
			System.out.println(c);
			}

	}

}

```

결과

```
Driver Loading Success...
DAOImple...Creating...
DB Server Connect..ok
Customer [num=111, name=JAMES, addr=NY]
Customer [num=333, name=tom, addr=방학동]
```



# Application

STORYLINE : 고객이 주식을 매수 매도 하는  Program을 만든다.

```
C:\miracom_edu\utill\jdbc_brocker
```



![broker_final](https://user-images.githubusercontent.com/83646543/140839466-039f22bc-bc9a-4244-afbc-a6b64a481e32.png)


## 작업Flow

UseCase Senario `->` 

SRS명세서(요구사항 정의서) `->`  

UseCaseDiagram`->` 

DB Modeling | 화면설계 | Class Diagram `->` 

VO 작성 `->` 

Business Login Template 도출 `->` 

구현





## DB Modeling

Client사용자가 사용할 기능을 도출 : useCase Diagram 

​	Generalization 엑터 사이에 쓴다

​	Include 기능이 선행되어져야 할때 

​	Extend 기능 

![Broker ucd-16360897326281](https://user-images.githubusercontent.com/83646543/140839787-5e0a7f4d-e449-45aa-85e2-4dc06bff892f.jpg)


**Use Case Diagram** :: 

시스템의 동작원리를 가장 잘 이해하기 위해서는 사용자 입장에서 시스템을 이해할수 있는 기능 중심의 뷰,사용자 관점



U.S.D가 나오면 방사형으로 아래와같은 것들을 만들수 있다. 

- 화면 설계Oven tool 

- DB Modeling
- B.C Template  이름, 인자값 인터페이스로 만들어 배포 



**Class Diagram** :: 

정적인 뷰를 제공하는 다이어그램 , 클래스 간의 관계를 한눈에 볼 수 있다.

수직(상속)/ 수평(has a) 관계



### - 개념설계 : Entitiy  추출

Program을 만들기 위한 필요한 Entity 추출

**Entity(실체) 추출** :: 

​    고객                     주식

​       |                           |

 PK주민번호             PK이름





### - 논리설계 : 

**속성추출** :: 

​                        고객          주식

​                           |               |

​	기본속성 -   이름          가격

​	일반속성 -   주소

**Entity간의 관계지정** ::

​            `-------->`

고객     다대다관계     주식

​            `<--------`

엔티티간의 관계가 다대다 일때는 이 관계를 해소해줘야 한다. 

=> 중간에 Association 



### - 물리적설계 :

**DB Table 생성** 



---



MySQL CMD

```
Enter password: ****
mysql> use scott;
mysql> source C:\miracom_edu\utill\jdbc_brocker\broker.sql

```



구현 순서

1. Table 작성

   Customer

   Stock

   Shares

2. VO작성

   CustomerRec.java

   StockRec.java

   SharesRec.java

3. DataBase Template

4. DataBase.java

5. Test :: BrokerGUI.java



![3333333333333](https://user-images.githubusercontent.com/83646543/140839509-47e4cc09-a2e6-4522-b5ab-3781d3c80321.png)


#### Database

jdbc04_Broker > broker.twotier.dao > Database.java

```java
package broker.twotier.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Vector;

import broker.twotier.exception.DuplicateSSNException;
import broker.twotier.exception.InvalidTransactionException;
import broker.twotier.exception.RecordNotFoundException;
import broker.twotier.vo.CustomerRec;
import broker.twotier.vo.SharesRec;
import broker.twotier.vo.StockRec;
import config.ServerInfo;
/*
 * 싱글톤 사용 X
 */
public class Database implements DatabaseTemplate{
	
	public Database(String serverIp) throws ClassNotFoundException{
		Class.forName(ServerInfo.DRIVER_NAME);
		System.out.println("드라이버 로딩 성공..");
	}
	@Override
	public Connection getConnect() throws SQLException {
		Connection conn =DriverManager.getConnection(ServerInfo.URL, ServerInfo.USER, ServerInfo.PASS);
		System.out.println("Database Connection......");
		return conn;
	}

	@Override
	public void closeAll(PreparedStatement ps, Connection conn) throws SQLException {
		if(ps!=null) ps.close();
		if(conn!=null) conn.close();			
	}

	@Override
	public void closeAll(ResultSet rs, PreparedStatement ps, Connection conn) throws SQLException {
		if(rs!=null) rs.close();
		closeAll(ps, conn);			
	}
	///----------------------- Business Methods ----------------------////
	// 존재유무를 확인해서 있으면 추가 안 되게, 없으면 삭제 못하도록, 없으면 수정 못하도록 해야 한다.
	//ssn이 있는지 없는지 확인하는 기능....하나 추가...isIsbn()과 동일한 기능
	public boolean isExist(String ssn, Connection conn)throws SQLException{
		String sql ="SELECT ssn FROM customer WHERE ssn=?";
		PreparedStatement ps = conn.prepareStatement(sql);
		
		ps.setString(1,ssn);
		ResultSet rs = ps.executeQuery();
		return rs.next();
	}
	
	// 회원가입
	@Override
	public void addCustomer(CustomerRec cust) throws SQLException, DuplicateSSNException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = getConnect();
			
			if(!isExist(cust.getSsn(), conn)) { //추가하려는 고객의 ssn이 없다면...추가
				String query = "INSERT INTO customer (ssn, cust_name, address) VALUES(?,?,?)";
				ps = conn.prepareStatement(query);
				
				ps.setString(1, cust.getSsn());
				ps.setString(2, cust.getName());
				ps.setString(3, cust.getAddress());
				
				System.out.println(ps.executeUpdate()+" 명 INSERT OK....addCustomer() ..");
			}else {
				throw new DuplicateSSNException();
			}			
		}finally {
			closeAll(ps, conn);
		}		
	}

	
	// 회원삭제
	@Override
	public void deleteCustomer(String ssn) throws SQLException, RecordNotFoundException {
		Connection conn = null;
		PreparedStatement ps = null;
		//외래키를 지정을 제약조건에 추가..customer 테이블에서 삭제를 하게되면 연결된 ssn이 shares 테이블에서도 자동 삭제될 것이다
		try {
			conn = getConnect();
			if(isExist(ssn, conn)) {
				String query = "DELETE FROM customer WHERE ssn=?";
				ps = conn.prepareStatement(query);					
				
				ps.setString(1, ssn);		
				
				System.out.println(ps.executeUpdate()+" 명 DELETE OK...deleteCustomer()...");				
			}else {
				throw new RecordNotFoundException();
			}			
		}finally {
			closeAll(ps, conn);
		}		
	}
	
	// 회원수정
	@Override
	public void updateCustomer(CustomerRec cust) throws SQLException, RecordNotFoundException {
		Connection conn = null;
		PreparedStatement ps = null;
		try {
			conn = getConnect();
			String query = "UPDATE customer SET cust_name=?, address = ?  WHERE ssn=?";
			
			ps = conn.prepareStatement(query);
			ps.setString(1, cust.getName());
			ps.setString(2, cust.getAddress());
			ps.setString(3, cust.getSsn());
			
			int row = ps.executeUpdate();
			if(row==1) System.out.println(row+" 명 UPDATE OK...updateCustomer()..");
			else throw new RecordNotFoundException();
		}finally {
			closeAll(ps, conn);
		}		
	}
	
	// 특정한 사람이 보유하고 있는 주식 정보를 받아오는 기능
	@Override
	public Vector<SharesRec> getPortfolio(String ssn) throws SQLException {

		// 리턴타입이 Vector<SharesRec> 인 이유? 
		// 보유하고 있는 주식 객체 share가 3가지(종목의 수가 정해짐) 
		Connection conn = null;
		 PreparedStatement ps = null;	
		 ResultSet rs = null;
		 Vector<SharesRec> v = new Vector<SharesRec>();
		 try{
			 conn = getConnect();
			 
			 String query ="SELECT ssn, symbol, quantity FROM shares WHERE ssn=?";
			 ps = conn.prepareStatement(query);
			 
			 ps.setString(1, ssn);
			 rs = ps.executeQuery();
			 while(rs.next()) {
				 v.add(new SharesRec(ssn, 
						 			 rs.getString("symbol"), 
						 			 rs.getInt("quantity")));
			 }
		 }finally {
			 closeAll(rs, ps, conn);
		 }
		return v;
	}
	
	// 특정한 사람에 대한 정보 
	@Override
	public CustomerRec getCustomer(String ssn) throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;	
		ResultSet rs = null;
		CustomerRec cust = null;
		try {
			conn = getConnect();
			String query = "SELECT ssn, cust_name, address FROM customer WHERE ssn=?";
			ps = conn.prepareStatement(query);
			ps.setString(1, ssn);
			
			rs = ps.executeQuery();
			if(rs.next()) { //ssn에 해당하는 고객이 있다면
				cust = new CustomerRec(ssn, 
									   rs.getString("cust_name"),
									   rs.getString("address"));
			}//if
			cust.setPortfolio(getPortfolio(ssn));
			
		}finally {
			closeAll(rs, ps, conn);
		}
		return cust;
	}
	
	// 모든 사람에 대한 정보
	@Override
	public ArrayList<CustomerRec> getAllCustomers() throws SQLException {
		Connection conn = null;
		PreparedStatement ps = null;	
		ResultSet rs = null;
		ArrayList<CustomerRec> list = new ArrayList<>();
		try {
			conn = getConnect();
			
			String query = "SELECT ssn, cust_name, address FROM customer";
			ps = conn.prepareStatement(query);
			
			rs = ps.executeQuery();
			while(rs.next()) {
				list.add(new CustomerRec(
							rs.getString("ssn"), 
							rs.getString("cust_name"), 
							rs.getString("address"), 
							getPortfolio(rs.getString("ssn"))));
			}
		}finally {
			closeAll(rs, ps, conn);
		}
		return list;
	}
	
	// 모든 주식에 대한 정보
	@Override
	public ArrayList<StockRec> getAllStocks() throws SQLException {
		 Connection conn = null;
		 PreparedStatement ps = null;	
		 ResultSet rs = null;
		 ArrayList<StockRec> list = new ArrayList<StockRec>();
		 try{
			 conn = getConnect();
			 String query = "SELECT symbol, price FROM stock";
			 ps = conn.prepareStatement(query);
			 rs = ps.executeQuery();
			 while(rs.next()){
				 list.add(new StockRec(rs.getString(1), 
						 			   rs.getFloat(2)));
			 }
		 }finally{
			 closeAll(rs, ps, conn);
		 }
		 return list;
	}
/*
 * 누가 어떤 주식을 몇개 살지를 정의하는 기능...
 * 
 * 지금 가지고 있는 주식의 갯수(quantity)부터 확인해봐야 한다.
 * 
 * 내가 현재 주식을 안가지고 있다 0 , 100--> insert into  100
 * 내가 현재 어느정도의 주식을 가지고 있다 50, 100--> update 150
 */
	// 매수
	@Override
	public void buyShares(String ssn, String symbol, int quantity) throws SQLException {
		 Connection conn = null;
		 PreparedStatement ps = null;	
		 ResultSet rs = null;
		 try {
			 conn=  getConnect();
			 
			 String query = "SELECT quantity FROM shares WHERE ssn=? AND symbol=?";
			 ps = conn.prepareStatement(query);
			 ps.setString(1, ssn);
			 ps.setString(2, symbol);
			 
			 rs = ps.executeQuery();
			 if(rs.next()) {
				 int q=rs.getInt(1); //q는 현재 가지고 있는 주식의 수량
				 int newQuantity = q+quantity; //  q(50) + quantity(100)
				 
				 //UPDATE
				 String query1 = "UPDATE shares SET quantity=? WHERE ssn=? AND symbol=?";
				 ps = conn.prepareStatement(query1);
				 ps.setInt(1, newQuantity);
				 ps.setString(2, ssn);
				 ps.setString(3, symbol);
				 
				 System.out.println(ps.executeUpdate()+" row buyShares()....UPDATE OK");
			 }else { //주식이 없는 경우..
				 //INSERT
				 String query2 ="INSERT INTO shares (ssn, symbol, quantity) VALUES(?,?,?)";
				 ps = conn.prepareStatement(query2);
				 ps.setString(1, ssn);
				 ps.setString(2, symbol);
				 ps.setInt(3, quantity);
				 
				 System.out.println(ps.executeUpdate()+" row buyShares()....INSERT OK");
			 }
		 }finally {
			 closeAll(rs, ps, conn);
		 }
		
	}
/*
 * 누가 어떤 주식을 몇개 팔것인가에 대한 기능을 정의...
 * 현재 가지고 있는 주식의 수량을 먼저 알아야 한다....int q
 * 
 * 1) 100개를 가지고 있다 ---- 50  SELL --- update
 * 2) 100개를 가지고 있다 ---- 100 SELL --- delete
 * 3) 100개를 가지고 있다 ---- 200 SELL --- InvalidTransactionException 펑!! 
 * 4) 팔려는 주식이 없을때 				 --- RecordNotFoundException 펑!!
 */
	// 매도
	@Override
	public void sellShares(String ssn, String symbol, int quantity)
			throws SQLException, InvalidTransactionException, RecordNotFoundException {
		
		Connection conn = null;
		 PreparedStatement ps = null;	
		 ResultSet rs = null;
		 try {
			 conn=  getConnect();
			 
			 String query ="SELECT quantity FROM shares WHERE ssn=? AND symbol=?";
			 ps = conn.prepareStatement(query);
			 ps.setString(1, ssn);
			 ps.setString(2, symbol);
			 
			 rs = ps.executeQuery();
			 
			 if(rs.next()){//일단 커서를 한단계 아래로 내려서 엘러먼트를 가리키게 하고 수량을 받아올 준비를 한다.
			 
				 int q = rs.getInt(1); // 현재 가지고 있는 수량...100
				 int newQuantity = q-quantity; //팔고 남은 수량
				 
				 if(q==quantity) { //delete
					 String query1 = "DELETE FROM shares WHERE ssn=? AND symbol=?";
					 ps = conn.prepareStatement(query1);
					 ps.setString(1, ssn);
					 ps.setString(2, symbol);
					 
					 System.out.println(ps.executeUpdate()+" row SHARES DELETE....sellShares()1...");
				 }else if(q>quantity) { //update
					 String query2 = "UPDATE shares SET quantity=? WHERE ssn=? AND symbol=?";
					 ps = conn.prepareStatement(query2);
					 
					 ps.setInt(1, newQuantity);
					 ps.setString(2, ssn);
					 ps.setString(3, symbol);
					 
					 System.out.println(ps.executeUpdate()+" row SHARES UPDATE....sellShares()2...");
				 }else {  //펑
					 throw new InvalidTransactionException();
				 }	
			 }else { //주식이 없다면..
				 throw new RecordNotFoundException();
			 }
		 	}finally {
		 		closeAll(rs, ps, conn);
		 	}
	}
}


```

####  DatabaseTest

jdbc04_Broker > broker.twotier.test> DatabaseTest.java

```java
package broker.twotier.test;

//import java.util.Vector;

import broker.twotier.dao.Database;
import broker.twotier.vo.CustomerRec;
import broker.twotier.vo.SharesRec;

public class DatabaseTest {

	public static void main(String[] args)throws Exception{
		
		Database db = new Database();
		db.addCustomer(new CustomerRec("777-777", "하바리", "다산동"));
//		db.deleteCustomer("777-777");
//		db.updateCustomer(new CustomerRec("111-111", "하바리", "약수동"));
		
//		Vector<SharesRec> v = db.getPortfolio("777-777");
//		for(SharesRec sr : v)System.out.println(v);
	}

}

```







# 최종 어플리케이션 화면 동작

broker.twotier.gui > Broker.java

```java
package broker.twotier.gui;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Color;
import java.awt.Frame;
import java.awt.GridLayout;
import java.awt.Label;
import java.awt.List;
import java.awt.Panel;
import java.awt.TextArea;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.StringTokenizer;
import java.util.Vector;

import broker.twotier.dao.Database;
import broker.twotier.exception.DuplicateSSNException;
import broker.twotier.exception.RecordNotFoundException;
import broker.twotier.vo.CustomerRec;
import broker.twotier.vo.SharesRec;
import broker.twotier.vo.StockRec;

//인터페이스 implements 한 상태로 클래스 선언하자
public class Broker implements ActionListener,ItemListener{
	private static int mode = 0;
	private static final int ADD_MODE = 1;
	private static final int UPDATE_MODE = 2;

	Database 		db;

	Frame 	frame =new Frame("ABC Stock");

	//*************컴포넌트 선언...생성 ************************
    //*******************************************************
	Panel 	pc =new Panel();
	Panel 	pe =new Panel();
	
	Panel 	   pec	=new Panel();
	Panel 	   pes	=new Panel();	
	
	
	Panel 	   pcn	=new Panel();
	Panel 	   pcc	=new Panel();
	Panel 	   pcw	=new Panel();
	Panel 	   pcs	=new Panel();
	

	Panel 		pcn1	=new Panel();
	Panel 		pcc1	=new Panel();
	Panel 		pcc2	=new Panel();
	
	Panel 		pcwn	=new Panel();
	Panel 		pcws	=new Panel();
	Panel 		pcwa	=new Panel();
	

	TextField nameTf	= new TextField(15);
	TextField ssnTf		= new TextField(15);
	TextField stockTf	= new TextField(15);
	TextField buyTf		= new TextField(15);
	TextField priceTf	= new TextField(15);
	TextField sellTf	= new TextField(15);

	TextArea addrTa	= new TextArea(3,15);

	List 	custList	= new List(15, false);
	List 	stockList	= new List(15, false);
	List 	portList	= new List(15, false);
	
	Button 	addB	= new Button("ADD");
	Button 	deleteB	= new Button("DELETE");
	Button 	updateB	= new Button("UPDATE");
	Button 	applyB	= new Button("apply");
	Button 	cancelB	= new Button("cancel");

	Button 	buyB	= new Button("Buy");
	Button 	sellB	= new Button("Sell");

	Button 	priceB	= new Button("Get Current Stock Price");

	// **************** 생성자 **************************************
	//*****************************************************************
	public Broker() throws Exception{
		
	   try	{	    
	    db =  new Database("127.0.0.1");
		} catch(Exception cnfe) {
			System.out.println("Broker Constructor : " + cnfe);
	
		}
		createGUI();
		addListener();

		showCustList(db.getAllCustomers(),custList);
		showStockList(db.getAllStocks(),stockList);
	
		initButton(true);
		emptyText();
		textEditable(false);

	}//생성자 닫고...

	// **********배경색, 전경색 지정 **********************
	//**************************************************
	public void createGUI() {	
	
		pc.setBackground(new Color(196 ,196  ,255  ));
		pe.setBackground(new Color(196 ,196  ,255  ));
		pec.setBackground(new Color(196 ,196  ,255  ));
		pes.setBackground(new Color(196 ,196  ,255  ));
		pcn.setBackground(new Color(196 ,196  ,255  ));
		pcc.setBackground(new Color(196 ,196  ,255  ));
		pcw.setBackground(new Color(196 ,196  ,255  ));
		pcs.setBackground(new Color(196 ,196  ,255  ));
		pcn1.setBackground(new Color(196 ,196  ,255  ));
		pcc1.setBackground(new Color(196 ,196  ,255  ));
		pcc2.setBackground(new Color(196 ,196  ,255  ));
		pcwn.setBackground(new Color(196 ,196  ,255  ));
		pcws.setBackground(new Color(196 ,196  ,255  ));
		pcwa.setBackground(new Color(196 ,196  ,255  ));
		custList.setBackground(new Color(142 ,142  ,255));
		stockList.setBackground(new Color(48 ,0  ,96));
		portList.setBackground(new Color(142 ,142  ,255));
		sellTf.setBackground(new Color(196 ,196  ,255));
	
	    frame.add(pc,"Center");
		frame.add(pe,"East");
		// *******************  컴포넌트 부착  ************************************
		// **********************************************************************
		pe.setLayout(new BorderLayout());
			pe.add(new Label("Stock Information", Label.CENTER), "North");
			pe.add(pec, "Center");
			pe.add(pes, "South");

			pec.setLayout(new BorderLayout());
			pec.add(new Label("Available Stocks"), "North");
			pec.add(stockList, "Center");
			pec.add(priceB, "South");
			pes.setLayout(new GridLayout(2, 2));
			pes.add(new Label("  Stock"));	
			pes.add(stockTf);
			pes.add(new Label("  Current Price"));	
			pes.add(priceTf);

		pc.setLayout(new BorderLayout());
			pc.add(pcn, "North");
			pc.add(pcc, "Center");
			pc.add(pcw, "West");
			pc.add(pcs, "South");

			GridLayout grid = new GridLayout(2, 1);
			pcn.setLayout(grid);
			grid.setHgap(20);
			pcn.add(new Label("Customer Information", Label.CENTER));
			pcn.add(pcn1);
			pcn1.add(addB);
			pcn1.add(deleteB);
			pcn1.add(updateB);
			pcn1.add(applyB);
			pcn1.add(cancelB);

			pcc.setLayout(new GridLayout(1, 2));
			pcc.add(pcc1);
			pcc1.setLayout(new BorderLayout());
			pcc1.add(new Label("Stock Portfolio"), "North");
			pcc1.add(portList);

			pcc.add(pcc2);
			pcc2.setLayout(new BorderLayout());
			pcc2.add(new Label("All Customers"), "North");
			pcc2.add(custList);

			pcw.setLayout(new GridLayout(3, 1));
			pcw.add(pcwn);
			pcwn.add(new Label("Name"));
			pcwn.add(nameTf);
			pcw.add(pcws);
			pcws.add(new Label("SSN"));
			pcws.add(ssnTf);
			pcw.add(pcwa);
			pcwa.add(new Label("Address"));
			pcwa.add(addrTa);

			pcs.add(buyB);
			pcs.add(buyTf);
			pcs.add(sellTf);
			pcs.add(sellB);

	// ************* 버튼 초기화 *****************************************
	// ****************************************************************
		buyB.setEnabled(true);
		sellB.setEnabled(true);

		stockTf.setEditable	(false);
		priceTf.setEditable	(false);
		buyTf.setEditable  	(false);

	
		frame.setSize(700, 350);
		frame.setLocation(100, 100);
		frame.setVisible(true);
	}//createGUI() 닫고


	// ************** 리스너 부착 ****************************************
	//*****************************************************************

    public void addListener()
	{
		addB.addActionListener(this);
		deleteB.addActionListener(this);
        updateB.addActionListener(this);
        applyB.addActionListener(this);
		cancelB.addActionListener(this);
		buyB.addActionListener(this);
        sellB.addActionListener(this);
        priceB.addActionListener(this);

		custList.addItemListener(this);
		stockList.addItemListener(this);
        portList.addItemListener(this);               

            
		//***********프레임 창 닫는 로직. ***********************************
		//****************************************************************
   		frame.addWindowListener(
			new WindowAdapter()	{	
				public void windowClosing(WindowEvent we){	
					System.exit(0);
				}
			}
		);
	} //addListener() 닫고....

	/*
	버튼을 Group(add, delete, update vs apply, cancel)하여
	Enable되게 하는 메소드
	*/
    public void initButton(boolean b){
		addB.setEnabled(b);
        deleteB.setEnabled(b);
        updateB.setEnabled(b);
		applyB.setEnabled(!b);
		cancelB.setEnabled(!b);
	}
	// name, ssn, address  TextField의 편집상태를 바꾼다
	public void textEditable(boolean b)	{
		nameTf.setEditable	(b);
		ssnTf.setEditable	(b);
		addrTa.setEditable	(b);
	}

	//ssn, name, address의 TextFiled 값을 clear 시킨다.
	public void emptyText(){
    	nameTf.setText("");
    	ssnTf.setText("");
    	addrTa.setText("");                              
    }
	//==================================================================
	// Database의 method를 호출
	//==================================================================

		// showList(db.getAllCustomer() , custList )
		/**
		 * 1)customer List area에 있는 모든걸 지운다<BR>
		 * 2)CustomerRec[]에 있는 모든 CustomerRec 객체 내용을 List에 뿌려준다<BR>
		 */
		public void showCustList(ArrayList<CustomerRec> cust, List list){
			list.removeAll();
			for(CustomerRec c : cust) {
				String ssn = c.getSsn();
				String name = c.getName();
				String addr = c.getAddress();
				
				list.add(ssn+"  "+name+"  "+addr);				
			}			
	    }	
		
		/**
		*argument로 받은 CustomerRec[]을 stockList에 하나씩 뿌려준다.<BR>
		 * 1)stock List area에 있는 모든걸 지운다.<BR>
		 * 2)StockRec[]에 있는 모든 StockRec 객체 내용을 List에 뿌려준다.<BR>
		 */
		public void showStockList(ArrayList<StockRec> sr, List list){
			list.removeAll();
			list.setForeground(Color.YELLOW);
			for(StockRec s : sr) {
				String symbol = s.getSymbol();
				float price = s.getPrice();
				list.add(symbol+" "+price);
			}			
		}

		
		 /**
		<PRE>
		 * 1)인자값으로 입력된 Vector타입의 portfolio 정보를 폼 리스트중 Stock Portfolio에 뿌려준다.
		 </PRE>
		 */    
		public void showList(Vector<SharesRec> portfolio, List list){
			list.removeAll();
			
			for(SharesRec s : portfolio) {
				String symbol = s.getSymbol();
				int quantity = s.getQuantity();
				list.add(symbol +" "+quantity);
			}			
		}
		
		 /**
		<PRE>
		 * 1)customer List에서 선택된 항목중에서 ssn을 Token한다
		 * 2)잘라진 ssn으로 DB의 getCustomer()를 이용. table에서 ssn에 해당하는 나머지 정보를 가져온다
		 * 3)가져온 정보를 ssn,name,address TextField와 port LIst에 뿌린다. 
		 </PRE>
		 */    
		public void showCustomer(){
			String customer=custList.getSelectedItem();
			StringTokenizer st = new StringTokenizer(customer);
			String ssn = st.nextToken();
			System.out.println(ssn);
			try{
				CustomerRec cr=db.getCustomer(ssn);
				nameTf.setText(cr.getName());
				ssnTf.setText(cr.getSsn());
				addrTa.setText(cr.getAddress());
				Vector<SharesRec> v=cr.getPortfolio();
				if(v !=null){ //주식을 보유한 고객이라면...
					showList(v, portList);
				}else{ //주식을 보유하지 않은 고객이라면...
					portList.removeAll();
				}
			}catch(SQLException e){
				System.out.println("찾는 고객의 정보가 없어여...showCustomer()...");
			}
			
			
		} 
		
		 /**
		<PRE>
		 * 1)ssn, symbol, quantity 정보를 알아온다 --> ssnTf, buyTf, sellTf의 텍스트박스에 입력된 값
		 * 2)각각의 값들을 인자로 DB의 buyShares()를 이용. 
		 * 3)폼의 Stock Portfolio에 주식의 정보와 수량이 뿌려지게 한다.
		 </PRE>
		 */   
		public void buyStock(){
			String ssn = ssnTf.getText().trim();
			System.out.println(ssn+"...buyStock()...");
			String symbol = buyTf.getText().trim();
			int quantity = Integer.parseInt(sellTf.getText());
			try{
				db.buyShares(ssn, symbol, quantity);
				showCustomer();//이거 안해주면 어떻게 되는 지 확인...
			}catch(SQLException e){
				e.printStackTrace();
			}				
			
		 } 
	  

		 /**
		<PRE>
		 * 1)ssn, symbol, quantity 정보를 알아온다 --> ssnTf, buyTf, sellTf의 텍스트박스에 입력된 값
		 * 2)각각의 값들을 인자로 DB의 sellShares()를 이용. 
		 * 3)폼의 Stock Portfolio에 주식의 정보와 수량이 뿌려지게 한다.
		 </PRE>
		 */   
		public void sellStock(){
			String ssn = ssnTf.getText().trim();
			System.out.println(ssn+"...sellStock()...");
			String symbol = buyTf.getText().trim();
			int quantity = Integer.parseInt(sellTf.getText());
			try{
				db.sellShares(ssn, symbol, quantity);
				
			}catch(SQLException e){
				e.printStackTrace();
			}catch(Exception e2){
				System.out.println("팔려는 주식이 넘 많아여...sellStock()");
			}
			showCustomer();//이거 안해주면 어떻게 되는 지 확인...
		}
		 
		 /**
		<PRE>
		 * 1)apply button에 의해 호출되는 메소드(Add button과 관련있다.)
		 * 2)nameTf,ssnTf,addrTa 에 입력된 값을 받아와 CustomerRec 객체를 생성
		 * 3)DB의 addCustomer()를 호출하고
		 * 4)최종적으로 List에 추가된 고객을 포함한 모든 고객의 리스트를 뿌린다.
		 </PRE>
		 */
		public void addCustomer(){
			
			String name = nameTf.getText().trim();
			String ssn = ssnTf.getText().trim();
			String address = addrTa.getText().trim();
			CustomerRec cr = new CustomerRec(ssn, name, address);
			
			try{
				db.addCustomer(cr);
				showCustList(db.getAllCustomers(), custList);
			}catch(DuplicateSSNException e){
				System.out.println("중복되는 고객 있어여...addCustomer()");
			}catch(SQLException e){
				e.printStackTrace();
			}
			
	    } 
		 /**
		<PRE>
		 * 1)apply button에 의해 호출되는 메소드(Add button과 관련있다.)
		 * 2)nameTf,ssnTf,addrTa 에 입력된 값을 받아와 CustomerRec 객체를 생성
		 * 3)DB의 updateCustomer()를 호출하고
		 * 4)최종적으로 List에 수정된 고객을 포함한 모든 고객의 리스트를 뿌린다.
		 </PRE>
		 */ 		  
		public void updateCustomer(){
			
			String name = nameTf.getText().trim();
			String ssn = ssnTf.getText().trim();
			String address = addrTa.getText().trim();
			CustomerRec cr = new CustomerRec(ssn, name, address);
			
			try{
				db.updateCustomer(cr);
				showCustList(db.getAllCustomers(), custList);
			}catch(RecordNotFoundException e){
				System.out.println("수정할 대상의 고객이 없어요...updateCustomer()");
			}catch(SQLException e){
				e.printStackTrace();
			}
			
			
	    } 
		
		/**
		//delete button에 의해 호출된다.
		 * 1)database의 deleteCustomer(ssn)call<BR>
		 * 2)showList(CustomerRec[],List) 호출<BR>
		 * 
		 */
		public void deleteCustomer(){
			String ssn = ssnTf.getText().trim();
			try{
				db.deleteCustomer(ssn);
				ArrayList<CustomerRec> list = db.getAllCustomers();
				showCustList(list, custList);
			}catch(Exception e){
				System.out.println("삭제하려는 고객이 없습니다. Broker.deleteCustomer() "+e);
			}
	    } 



		
		/**
		<PRE>
		*stockList에 선택된 내용을
		*buyTf, sockTf, priceTf TextField에 뿌려준다.
		 * 1)stock List 중에서 선택된 항목을 Token한다.
		 * 2)symbol,price를 해당 textfield에 setting 한다.
		 </PRE>
		 */
		public void showStock(){
			String stock = stockList.getSelectedItem();
			StringTokenizer st = new StringTokenizer(stock);
			String symbol = st.nextToken().trim();
			String price = st.nextToken().trim();
			
			buyTf.setText(symbol);
			stockTf.setText(symbol);
			priceTf.setText(price);
		}

		  /**
		*portList에 선택된 내용을 buy, sell TextField에 뿌려준다.
		 * 1)port List에서 선택된 항목을 Token한다.<BR>
		 * 2)symbol,quantity를 해당 textfield에 setting한다<BR>
		 */
		public void showPortfolio(){
			String portfolio = portList.getSelectedItem();
			StringTokenizer st = new StringTokenizer(portfolio);
			String symbol = st.nextToken();
			String quantity = st.nextToken();
			
			buyTf.setText(symbol);
			sellTf.setText(quantity);
	   	}


	//============================================================
	// Event Handling 처리
	//=============================================================

		 /**
		<PRE>
		 * List내에서 다른 아이템을 선택하면 call
		 * 1)이 메소드 호출시 언제나 2개의 textfield(buy,sell)의 상태를 null로 만들것
		 * 2)이 메소드를 호출시킨 event source가
		 *   customer List일 경우 : showCustomer() method call
		 *   portfolio List일 경우 : showPortfolio() method call
		 *   stock List 일 경우 : showStock() method call
		</PRE>
		 */
		public void itemStateChanged(ItemEvent ie) {
			buyTf.setText("");
			sellTf.setText("");
			List list = (List)ie.getSource();
			if(list.equals(custList)){
				showCustomer();
			}else if(list.equals(stockList)){
				showStock();
			}else{
				showPortfolio();
			}		
			
		}
		//Button들이 eventHandling
		public void actionPerformed(ActionEvent ae){
			String buttonLabel = ae.getActionCommand();
			if(buttonLabel.equals("ADD")){
				initButton(false);
				textEditable(true);
				emptyText(); 
				nameTf.requestFocus();
				mode = ADD_MODE;
				System.out.println(mode);
			}else if(buttonLabel.equals("DELETE")){
				deleteCustomer();
				emptyText();
			}else if(buttonLabel.equals("UPDATE")){
				initButton(false);
				textEditable(true);
				nameTf.requestFocus();
				mode = UPDATE_MODE;
				System.out.println(mode);
			}else if (buttonLabel.equals("apply"))	{
			
				switch(mode){
					case ADD_MODE:
						addCustomer();
						emptyText();
						textEditable(false);
						initButton(true);
						break;
					case UPDATE_MODE:
						updateCustomer();
						textEditable(false);
						initButton(true);
						break;
				}
			}else if(buttonLabel.equals("cancel")){
				initButton(true);
				emptyText();
				textEditable(false);
			}else if(buttonLabel.equals("Buy")){
				buyStock();
				sellTf.setText("");
			}else if (buttonLabel.equals("Sell")){
				sellStock();
				sellTf.setText("");
				System.out.println(0);
			}
		}
	public static void main(String args[])throws Exception {
		Broker broker = new Broker();		
	}
}

```

